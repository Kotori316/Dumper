import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

buildscript {
    repositories {
        mavenCentral()
        maven { url = "https://maven.minecraftforge.net/" }
        maven { url = 'https://maven.parchmentmc.org' }
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
        classpath 'org.parchmentmc:librarian:1.+'
    }
}
plugins {
    id('scala')
    id "com.github.breadmoirai.github-release" version "2.2.12"
}
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.parchmentmc.librarian.forgegradle'
//Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.


version = project.modVersion
group = "com.kotori316" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "Dumper-18.1"

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

minecraft {
    mappings channel: 'parchment', version: project.parchmentMapping
    runs {
        client {
            workingDirectory project.file('Minecraft')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property('mixin.env.remapRefMap', 'true')
            property('mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg")
            property "mixin.debug.export", "true"
            property 'forge.logging.console.level', 'info'
            forceExit false

            mods {
                kotori_dumper {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run-server')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property('mixin.env.remapRefMap', 'true')
            property('mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg")
            property "mixin.debug.export", "true"
            property 'forge.logging.console.level', 'info'
            forceExit false

            mods {
                kotori_dumper {
                    source sourceSets.main
                }
            }
        }
    }
}

repositories {
    maven {
        name = "Azure-SLP"
        url = uri("https://pkgs.dev.azure.com/Kotori316/minecraft/_packaging/mods/maven/v1")
        content {
            includeModule("com.kotori316", "ScalableCatsForce".toLowerCase())
            it.includeVersion("org.typelevel", "cats-core_2.13", "2.6.2-kotori")
            it.includeVersion("org.typelevel", "cats-kernel_2.13", "2.6.2-kotori")
        }
    }
}

dependencies {
    minecraft('net.minecraftforge:forge:' + project.forgeVersion)
    implementation(group: 'org.scala-lang', name: 'scala-library', version: '2.13.7')
    implementation(group: 'org.typelevel', name: "cats-core_2.13", version: '2.6.2-kotori')

    runtimeOnly(group: "com.kotori316", name: "ScalableCatsForce".toLowerCase(), version: "2.13.7-build-1", classifier: "with-library") {
        transitive(false)
    }
}

def jarAttributeMap = [
        "Specification-Title"     : project.name,
        "Specification-Vendor"    : "Kotori316",
        "Specification-Version"   : "1", // We are version 1 of ourselves
        "Implementation-Title"    : project.name,
        "Implementation-Version"  : project.version,
        "Implementation-Vendor"   : "Kotori316",
        "Implementation-Timestamp": ZonedDateTime.now().format(DateTimeFormatter.ISO_INSTANT),
        'Automatic-Module-Name'   : 'dumper',
]

jar {
    manifest {
        attributes(jarAttributeMap)
    }
}

task srcJar(type: Jar) {
    from sourceSets.main.allSource
    archiveClassifier.set("sources")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task deobfJar(type: Jar) {
    from sourceSets.main.output
    archiveClassifier.set("deobf")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
        attributes(jarAttributeMap)
    }
}

// Tell the artifact system about our extra jars
artifacts {
    archives srcJar, deobfJar
}

task signJar2() {
    doLast {
        ant.signjar(
                jar: jar.getArchiveFile().get(),
                alias: project.hasProperty('keyStoreAlias') ? project.getProperty('keyStoreAlias') : "",
                keystore: project.hasProperty('keyStore') ? project.getProperty("keyStore") : "",
                storepass: project.hasProperty('keyStorePass') ? project.getProperty('keyStorePass') : "",
                sigalg: "SHA1withRSA",
                digestalg: "SHA-256",
                tsaurl: "http://timestamp.digicert.com"
        )
        ant.signjar(
                jar: deobfJar.getArchiveFile().get(),
                alias: project.hasProperty('keyStoreAlias') ? project.getProperty('keyStoreAlias') : "",
                keystore: project.hasProperty('keyStore') ? project.getProperty("keyStore") : "",
                storepass: project.hasProperty('keyStorePass') ? project.getProperty('keyStorePass') : "",
                sigalg: "SHA1withRSA",
                digestalg: "SHA-256",
                tsaurl: "http://timestamp.digicert.com"
        )
    }
}

if (!Boolean.valueOf(System.getenv("GITHUB_ACTIONS"))) {
    // Runs this task automatically when build is ran.
    assemble.dependsOn(signJar2)
}

githubRelease {
    repo.set('Dumper')
    token = project.hasProperty("REPO_TOKEN") ? getProperty("REPO_TOKEN") : String.valueOf(System.getenv("REPO_TOKEN"))
    targetCommitish.set('1.18')
    releaseAssets = files(
            jar.getArchiveFile().get(),
            deobfJar.getArchiveFile().get(),
            srcJar.getArchiveFile().get()
    )
    overwrite.set(true)
}

task checkOutput() {
    doLast {
        FilenameFilter filter = { dir, filename -> filename.contains(project.version.toString()) }
        println(project.version.toString())
        println(jar.getArchiveFile().get())
        println(deobfJar.getArchiveFile().get())
        println(srcJar.getArchiveFile().get())
        println(jar.getDestinationDirectory().orNull)
        println(jar.getDestinationDirectory().map { it.getAsFile().listFiles(filter) }.orNull)
    }
}
